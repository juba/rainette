<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="rainette">
<title>[en] Algorithms description • rainette</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.1.0/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.1.0/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="[en] Algorithms description">
<meta property="og:description" content="rainette">
<meta property="og:image" content="https://juba.github.io/rainette/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">rainette</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.3.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/introduction_en.html">[en] Introduction to rainette</a>
    <a class="dropdown-item" href="../articles/algorithms_en.html">[en] Algorithms description</a>
    <a class="dropdown-item" href="../articles/introduction_usage.html">[fr] Utilisation de rainette</a>
    <a class="dropdown-item" href="../articles/algorithmes.html">[fr] Description des algorithmes</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/juba/rainette/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">



<script src="algorithms_en_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <main id="main"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>[en] Algorithms description</h1>
                        <h4 data-toc-skip class="author">Julien Barnier</h4>
            
            <h4 data-toc-skip class="date">2022-03-16</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/juba/rainette/blob/HEAD/vignettes/algorithms_en.Rmd" class="external-link"><code>vignettes/algorithms_en.Rmd</code></a></small>
      <div class="d-none name"><code>algorithms_en.Rmd</code></div>
    </div>

    
    
<p>The goal of this document is to describe the algorithms used in the <code>rainette</code> package and their implementation. This implementation has been based upon two main resources :</p>
<ul>
<li>the three papers from Max Reinert cited in <a href="#references">references</a> (in french)</li>
<li>the source code of <a href="http://www.iramuteq.org/" class="external-link">Iramuteq</a>, especially the <code>CHD.R</code> and <code>chdtxt.R</code> files. Note however that the code has been almost entirely rewritten (in part in C++ via <a href="http://rcpp.org/" class="external-link">Rcpp</a>).</li>
</ul>
<div class="section level2">
<h2 id="simple-clustering-algorithm">Simple clustering algorithm<a class="anchor" aria-label="anchor" href="#simple-clustering-algorithm"></a>
</h2>
<div class="section level3">
<h3 id="document-term-matrix">Document-term matrix<a class="anchor" aria-label="anchor" href="#document-term-matrix"></a>
</h3>
<p>The simple clustering method is a divisive hierarchical clustering applied to a document-term matrix. This matrix is binary weighted, so only the absence or presence of a term in a document is taken into account.</p>
<p>Here is a sample matrix :</p>
<pre><code><span class="co">##      return of the obra dinn</span>
<span class="co">## doc1      1  1   1    1    1</span>
<span class="co">## doc2      0  0   1    1    1</span>
<span class="co">## doc3      1  1   1    0    0</span>
<span class="co">## doc4      0  1   0    0    0</span></code></pre>
<p>Note that if documents are segments computed by <code><a href="../reference/split_segments.html">split_segments()</a></code>, segments from the same source may be merged together before clustering computation if some of them are too short and don’t reach the minimum size given by the <code>min_segment_size</code> argument of <code><a href="../reference/rainette.html">rainette()</a></code>.</p>
</div>
<div class="section level3">
<h3 id="maximal-χ²-splitting">Maximal χ² splitting<a class="anchor" aria-label="anchor" href="#maximal-%CF%87%C2%B2-splitting"></a>
</h3>
<p>In the newt step, the goal is to split the document-term matrix into two groups of documents such as these are as “different” as possible. For the Reinert method, the “best” split is the one which maximizes the χ² value of the grouped array.</p>
<p>For example, using the previous matrix, if we group together <code>doc1</code> with <code>doc2</code> and <code>doc3</code> with <code>doc4</code>, we get the following grouped array :</p>
<pre><code><span class="co">##             return of the obra dinn</span>
<span class="co">## doc1 + doc2      1  1   2    2    2</span>
<span class="co">## doc3 + doc4      1  2   1    0    0</span></code></pre>
<p>We can compute the χ² statistics of this array, which can be seen has an association coefficient between the two document groups regarding their term distributions : if the χ² is high, the two groups are different, if it is low they can be considered as similar.</p>
<p>In such a simple case, we could compute every possible groupings and determine which one corresponds to the maximal χ² value, but with real data the complexity and needed computations rise very rapidly.</p>
<p>The Reinert method therefore proceeds the following way :</p>
<ul>
<li>we first compute a correspondance analysis on the document-term matrix, and we sort the documents along their coordinate on the first axis.</li>
<li>we group documents together successively following this ordering : first the lowest coordinate document <em>vs</em> all the others, then the two lowest ones <em>vs</em> all the others, and so on. Each time we compute the χ² value of the grouped matrix, and we keep the grouping which corresponds to the highest χ² value.</li>
<li>based on this grouping, we succesively assign each document to the other group, and see if this makes the χ² rise. If it is the case, the document is kept in the other group. This operation is repeated until no reassignment makes the χ² higher.</li>
</ul>
<p>At the end we get two groups of documents and two corresponding document-term matrices.</p>
</div>
<div class="section level3">
<h3 id="terms-selection">Terms selection<a class="anchor" aria-label="anchor" href="#terms-selection"></a>
</h3>
<p>The following step is to filter out some terms from each matrices before the next iteration :</p>
<ul>
<li>we compute each term frequency in both matrices, and remove terms with a frequency lower than 3 (this value can be changed using the <code>tsj</code> argument of <code><a href="../reference/rainette.html">rainette()</a></code>).</li>
<li>we also compare the observed frequency of each term and their expected frequency under independance hypothesis of distribution between the two groups. This allows to compute a contingency coefficient : if this coefficient is higher than 0.3, the term is only kept in the matrix where it is overrepresented (the 0.3 threshold can be changed using the <code>cc_test</code> argument of <code><a href="../reference/rainette.html">rainette()</a></code>).</li>
</ul>
</div>
<div class="section level3">
<h3 id="divisive-hierarchical-clustering">Divisive hierarchical clustering<a class="anchor" aria-label="anchor" href="#divisive-hierarchical-clustering"></a>
</h3>
<p>The previous steps allow to split a documents corpus into two groups. To get a hierarchy of groups, we first split the whole initial corpus, then continue by splitting the biggest resulting cluster, <em>ie</em> the one with the most documents (unless the cluster document-term matrix is too small to compute a correspondance analysis, or if its size is smaller than the value of the <code>min_split_members</code> argument of <code><a href="../reference/rainette.html">rainette()</a></code>).</p>
<p>By repeating this <code>k - 1</code> times, we get a divisive hierarchical clustering of <code>k</code> clusters, and the corresponding dendrogram (the height of each dendrogram branch is given by the χ² value of the corresponding split).</p>
<p><img src="img/dendro5.png"></p>
</div>
</div>
<div class="section level2">
<h2 id="double-clustering-algorithm">Double clustering algorithm<a class="anchor" aria-label="anchor" href="#double-clustering-algorithm"></a>
</h2>
<p>The double clustering only applies to a corpus which has been split into segments. The goal is to make clusters more robust by crossing the results of two single clusterings computed with different minimal segment sizes.</p>
<p>Doing a double clustering implies therefore implies that we first do two simple clusterings with distinct <code>min_segment_size</code> values. We then get two different dendrograms determining different clusters, here numbered from 1 to 6 :</p>
<p><img src="img/double_cdh1.png"></p>
<div class="section level3">
<h3 id="cross-clusters-computation">Cross-clusters computation<a class="anchor" aria-label="anchor" href="#cross-clusters-computation"></a>
</h3>
<p>The first step of the algorithm is to cross all clusters from both dendrograms together :</p>
<p><img src="img/double_cdh_full.png"></p>
<p>Each cluster of the first simple clustering is crossed with each cluster of the second one, even if both cluster do not belong to the same <code>k</code> level. The new resulting cluster is called a “crossed cluster” :</p>
<ul>
<li>for each crossed cluster, we compute its size, <em>ie</em> the number of segments belonging to both clusters.</li>
<li>using this size, the size of both clusters and the total number of segments, we can create a cross table of clusters membership : we compute the χ² value of this table, which can be seen as an “association coefficient” between the two clusters.</li>
<li>if two different crossed clusters hold exactly the same segments, we only keep one.</li>
<li>if a crossed cluster size is lower than the value of the <code>min_members</code> argument of <code><a href="../reference/rainette2.html">rainette2()</a></code>, it is discarded.</li>
<li>if a crossed cluster has an association χ² lower than the value of the <code>min_chi2</code> argument of <code><a href="../reference/rainette2.html">rainette2()</a></code>, it is discarded.</li>
</ul>
<table class="table">
<thead><tr>
<th align="center">
Crossed cluster
</th>
<th align="right">
Size
</th>
<th align="right">
Association χ²
</th>
</tr></thead>
<tbody>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>1</span></span>
</td>
<td align="right">
25
</td>
<td align="right">
41.2
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>2</span></span>
</td>
<td align="right">
102
</td>
<td align="right">
30.1
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>3</span></span>
</td>
<td align="right">
59
</td>
<td align="right">
87.3
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>4</span></span>
</td>
<td align="right">
41
</td>
<td align="right">
94.0
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>5</span></span>
</td>
<td align="right">
0
</td>
<td align="right">
-
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>6</span></span>
</td>
<td align="right">
13
</td>
<td align="right">
6.2
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>2</span><span>1</span></span>
</td>
<td align="right">
0
</td>
<td align="right">
-
</td>
</tr>
<tr>
<td align="center">
…
</td>
<td align="right">
…
</td>
<td align="right">
…
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>6</span><span>6</span></span>
</td>
<td align="right">
5
</td>
<td align="right">
3.1
</td>
</tr>
</tbody>
</table>
<p>Once these crossed clusters have been computed, two types of analysis are possible.</p>
<div class="section level4">
<h4 id="full-analysis">“full” analysis<a class="anchor" aria-label="anchor" href="#full-analysis"></a>
</h4>
<p>The first type, called a “full” analysis (<code>full = TRUE</code> argument of <code><a href="../reference/rainette2.html">rainette2()</a></code>), retains for the following steps all the crossed clusters with a size greater than zero (if these have not already been filtered out at the previous step). In the previous example, we would keep :</p>
<table class="table">
<thead><tr>
<th align="center">
Crossed cluster
</th>
<th align="right">
Size
</th>
<th align="right">
Association χ²
</th>
</tr></thead>
<tbody>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>1</span></span>
</td>
<td align="right">
25
</td>
<td align="right">
41.2
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>2</span></span>
</td>
<td align="right">
102
</td>
<td align="right">
30.1
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>3</span></span>
</td>
<td align="right">
59
</td>
<td align="right">
87.3
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>4</span></span>
</td>
<td align="right">
41
</td>
<td align="right">
94.0
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>6</span></span>
</td>
<td align="right">
13
</td>
<td align="right">
6.2
</td>
</tr>
<tr>
<td align="center">
…
</td>
<td align="right">
…
</td>
<td align="right">
…
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>6</span><span>6</span></span>
</td>
<td align="right">
5
</td>
<td align="right">
3.1
</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="classical-analysis">“classical” analysis<a class="anchor" aria-label="anchor" href="#classical-analysis"></a>
</h4>
<p>The second type, called a “classical” analysis (<code>full = FALSE</code> argument of <code><a href="../reference/rainette2.html">rainette2()</a></code>), only keeps for the following steps the crossed clusters whose clusters are mutually most associated. Thus, if we consider the crossed cluster crossing cluster <em>x</em> and cluster <em>y</em>, we only keep this crossed cluster if <em>y</em> is the cluster with the highest association χ² with <em>x</em>, and if at the same time <em>x</em> is the cluster with the highest association χ² with <em>y</em>.</p>
<p>In this case the number of crossed clusters kept for the following steps is much lower :</p>
<table class="table">
<thead><tr>
<th align="center">
Crossed cluster
</th>
<th align="right">
Size
</th>
<th align="right">
Association χ²
</th>
</tr></thead>
<tbody>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>4</span></span>
</td>
<td align="right">
41
</td>
<td align="right">
94.0
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>3</span><span>3</span></span>
</td>
<td align="right">
18
</td>
<td align="right">
70.1
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>4</span><span>6</span></span>
</td>
<td align="right">
21
</td>
<td align="right">
58.2
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>6</span><span>5</span></span>
</td>
<td align="right">
25
</td>
<td align="right">
61.0
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section level3">
<h3 id="determining-optimal-partitions">Determining optimal partitions<a class="anchor" aria-label="anchor" href="#determining-optimal-partitions"></a>
</h3>
<p>The goal of the next step is to identify, starting from the set of crossed clusters defined previously, every possible partitions of our corpus in 2, 3, 4… crossed clusters. More precisely, we try to identify each set of 2, 3, 4… crossed clusters which have no common elements.</p>
<p>We start by computing the size 2 partitions, <em>ie</em> every set of 2 crossed clusters without common elements. For each partition we compute is total size and the sum of its association χ².</p>
<table class="table">
<thead><tr>
<th align="center">
Partition
</th>
<th align="right">
Total size
</th>
<th align="right">
Sum of association χ²
</th>
</tr></thead>
<tbody>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>1</span></span> <span class="cross"><span>2</span><span>3</span></span>
</td>
<td align="right">
47
</td>
<td align="right">
62.3
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>4</span></span> <span class="cross"><span>3</span><span>5</span></span>
</td>
<td align="right">
36
</td>
<td align="right">
51.0
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>2</span><span>4</span></span> <span class="cross"><span>1</span><span>6</span></span>
</td>
<td align="right">
29
</td>
<td align="right">
38.2
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>2</span></span> <span class="cross"><span>5</span><span>3</span></span>
</td>
<td align="right">
143
</td>
<td align="right">
68.7
</td>
</tr>
<tr>
<td align="center">
…
</td>
<td align="right">
…
</td>
<td align="right">
…
</td>
</tr>
</tbody>
</table>
<p>We only keep among these partitions the ones that are considered the “best” ones :</p>
<ul>
<li>if we are doing a “full” analysis (<code>full = TRUE</code>), we keep the one having the highest sum of χ², and the one with the highest total size.</li>
<li>if we are doing a “classical” analysis (<code>full = FALSE</code>), we only keep the one with the highest sum of χ² (we can use the highest total size criterion in this case).</li>
</ul>
<table class="table">
<thead><tr>
<th align="center">
Partition
</th>
<th align="right">
Total size
</th>
<th align="right">
Sum of association χ²
</th>
</tr></thead>
<tbody>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>2</span></span> <span class="cross"><span>5</span><span>3</span></span>
</td>
<td align="right">
143
</td>
<td align="right">
68.7
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>3</span><span>4</span></span> <span class="cross"><span>2</span><span>6</span></span>
</td>
<td align="right">
86
</td>
<td align="right">
98.0
</td>
</tr>
</tbody>
</table>
<p>We do the same for the size 3 partitions : we identify every set of 3 non overlapping crossed clusters, and keep the “best” ones.</p>
<table class="table">
<thead><tr>
<th align="center" style="width: 50%;">
Partition
</th>
<th align="right">
Total size
</th>
<th align="right">
Sum of association χ²
</th>
</tr></thead>
<tbody>
<tr>
<td align="center">
<span class="cross"><span>1</span><span>2</span></span> <span class="cross"><span>5</span><span>3</span></span> <span class="cross"><span>2</span><span>5</span></span><br>
</td>
<td align="right">
189
</td>
<td align="right">
91.3
</td>
</tr>
<tr>
<td align="center">
<span class="cross"><span>3</span><span>4</span></span> <span class="cross"><span>2</span><span>6</span></span> <span class="cross"><span>5</span><span>3</span></span>
</td>
<td align="right">
113
</td>
<td align="right">
108.1
</td>
</tr>
</tbody>
</table>
<p>And we repeat the operation for 4 crossed clusters, etc.</p>
<table style="margin-top: 2em;" class="table">
<thead><tr>
<th align="center" style="width: 50%;">
Partition
</th>
<th align="right">
Total size
</th>
<th align="right">
Sum of association χ²
</th>
</tr></thead>
<tbody><tr>
<td align="center">
<span class="cross"><span>3</span><span>4</span></span><span class="cross"><span>2</span><span>6</span></span><span class="cross"><span>5</span><span>3</span></span><span class="cross"><span>1</span><span>5</span></span><br>
</td>
<td align="right">
223
</td>
<td align="right">
114.7
</td>
</tr></tbody>
</table>
<p>The operation is repeated until we reach the value of the <code>max_k</code> argument passed to <code><a href="../reference/rainette2.html">rainette2()</a></code>, or until there is no possible partition of the size <code>k</code>.</p>
</div>
<div class="section level3">
<h3 id="result">Result<a class="anchor" aria-label="anchor" href="#result"></a>
</h3>
<p>At the end we get, for each <code>k</code> value from 2 to <code>max_k</code>, a selection of the “best” crossed clusters partitions, either according to the association χ² criterion or according to the total size criterion. These crossed clusters form a new set of clusters which are potentially more “robust” than the ones computed from the two simple clusterings.</p>
<p>After this operation, a potentially high number of segments may not belong to any cluster anymore. <code>rainette</code> allows to reassign them to the new clusters with a fast <em>k-nearest neighbours</em> method, but this may not be recommended as we would then loose the clusters robustness acquired with the double clustering.</p>
</div>
</div>
<div class="section level2">
<h2 id="differences-with-the-reinert-method">Differences with the “Reinert method”<a class="anchor" aria-label="anchor" href="#differences-with-the-reinert-method"></a>
</h2>
<p>The way to determine the optimal partitions did not seem completely clear to us in the articles cited in <a href="#references">references</a>, so it is not really possible to compare with the <code>rainette</code> implementation. The “classical” method described in this document seems to be close from the one suggested by Max Reinert : after computing the crossed clusters, we only keep the ones where the two crossed clusters are both the most mutually associated.</p>
<p>One important difference is the fact that once the best partition of crossed clusters has been determined, Max Reinert suggests to use these new groups as starting points to reassign the documents to new clusters with a k-means type method. This is not implemented in <code>rainette</code> : the <code><a href="../reference/rainette2_complete_groups.html">rainette2_complete_groups()</a></code> allows to reassign documents without cluster using a <em>k-nearest neighbours</em> method, but this may not be recommended if you want to keep the “robustness” of the clusters computed with the double clustering.</p>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<ul>
<li>Reinert M., “Une méthode de classification descendante hiérarchique : application à l’analyse lexicale par contexte”, <em>Cahiers de l’analyse des données</em>, Volume 8, Numéro 2, 1983. <a href="http://www.numdam.org/item/?id=CAD_1983__8_2_187_0" class="external-link uri">http://www.numdam.org/item/?id=CAD_1983__8_2_187_0</a>
</li>
<li>Reinert M., “Alceste une méthodologie d’analyse des données textuelles et une application: Aurelia De Gerard De Nerval”, <em>Bulletin de Méthodologie Sociologique</em>, Volume 26, Numéro 1, 1990. <a href="https://doi.org/10.1177/075910639002600103" class="external-link uri">https://doi.org/10.1177/075910639002600103</a>
</li>
<li>Reinert M., “Une méthode de classification des énoncés d’un corpus présentée à l’aide d’une application”, <em>Les cahiers de l’analyse des données</em>, Tome 15, Numéro 1, 1990. <a href="http://www.numdam.org/item/?id=CAD_1990__15_1_21_0" class="external-link uri">http://www.numdam.org/item/?id=CAD_1990__15_1_21_0</a>
</li>
</ul>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Julien Barnier.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.2.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
